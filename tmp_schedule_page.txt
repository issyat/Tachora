"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { Modal } from "@/components/ui/modal";

// Timeline config
const START_HOUR = 9; // 09:00
const END_HOUR = 22; // 22:00
const HOUR_WIDTH = 96; // px per hour
const LANE_HEIGHT = 28; // px per lane
const LANE_GAP = 6; // px between lanes
const MIN_ROW_HEIGHT = 56; // px minimum height for empty days

const dayOrder = [
  { key: "MON", label: "Mon" },
  { key: "TUE", label: "Tue" },
  { key: "WED", label: "Wed" },
  { key: "THU", label: "Thu" },
  { key: "FRI", label: "Fri" },
  { key: "SAT", label: "Sat" },
  { key: "SUN", label: "Sun" },
] as const;

type DayKey = (typeof dayOrder)[number]["key"];

type Template = {
  role: string;
  days: Record<DayKey, boolean> | Record<string, boolean>;
  startTime: string; // HH:mm
  endTime: string; // HH:mm
};

type Employee = {
  name: string;
  email: string;
  phone: string;
  label: string;
  color: string;
  availability: { day: string; isOff: boolean; startTime: string; endTime: string }[];
  _index?: number;
};

type SetupResponse = {\n  store: { id: string } | null;\n  shiftTemplates: Template[];\n  employees: Employee[];\n};

function timeToMinutes(t: string): number {
  const m = /^(\d{2}):(\d{2})$/.exec(t);
  if (!m) return START_HOUR * 60;
  const hh = Number(m[1]);
  const mm = Number(m[2]);
  return hh * 60 + mm;
}

function clampToWindow(min: number, max: number) {
  const start = Math.max(min, START_HOUR * 60);
  const end = Math.min(max, END_HOUR * 60);
  return { start, end, valid: end > start };
}

function useSetup(): { templates: Template[]; employees: Employee[]; loading: boolean; error: string | null } {
  const [templates, setTemplates] = useState<Template[]>([]);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let active = true;
    setLoading(true);
    fetch("/api/setup", { cache: "no-store" })
      .then((r) => r.json())
      .then((json: SetupResponse) => {
        if (!active) return;
        const emps = (json.employees ?? []).map((e, i) => ({ ...e, _index: i }));
        setTemplates(json.shiftTemplates ?? []);
        setEmployees(emps);
        setLoading(false);
      })
      .catch((e) => {
        console.error(e);
        if (!active) return;
        setError("Unable to load setup data");
        setLoading(false);
      });
    return () => {
      active = false;
    };
  }, []);

  return { templates, employees, loading, error };
}

type Block = {
  role: string;
  startMin: number; // absolute minutes of day
  endMin: number;
};

type LaidBlock = Block & { lane: number };

type DayLayout = {
  day: DayKey;
  lanes: LaidBlock[];
  laneCount: number;
};

function layoutDay(blocks: Block[]): DayLayout {
  // Greedy lane placement by start time
  const sorted = [...blocks].sort((a, b) => a.startMin - b.startMin);
  const laneEnds: number[] = []; // endMin per lane
  const placed: LaidBlock[] = [];

  for (const b of sorted) {
    let lane = laneEnds.findIndex((end) => end <= b.startMin);
    if (lane === -1) {
      lane = laneEnds.length;
      laneEnds.push(b.endMin);
    } else {
      laneEnds[lane] = b.endMin;
    }
    placed.push({ ...b, lane });
  }

  return { day: "MON", lanes: placed, laneCount: laneEnds.length } as DayLayout; // day replaced by caller
}

function buildLayouts(templates: Template[]): Record<DayKey, DayLayout> {
  const result: Record<DayKey, DayLayout> = {
    MON: { day: "MON", lanes: [], laneCount: 0 },
    TUE: { day: "TUE", lanes: [], laneCount: 0 },
    WED: { day: "WED", lanes: [], laneCount: 0 },
    THU: { day: "THU", lanes: [], laneCount: 0 },
    FRI: { day: "FRI", lanes: [], laneCount: 0 },
    SAT: { day: "SAT", lanes: [], laneCount: 0 },
    SUN: { day: "SUN", lanes: [], laneCount: 0 },
  };

  const dayMap: Record<DayKey, Block[]> = {
    MON: [], TUE: [], WED: [], THU: [], FRI: [], SAT: [], SUN: [],
  };

  for (const t of templates) {
    const start = timeToMinutes(t.startTime);
    const end = timeToMinutes(t.endTime);
    const { start: s, end: e, valid } = clampToWindow(start, end);
    if (!valid) continue;
    for (const d of dayOrder) {
      const on = Boolean((t.days as Record<string, boolean>)?.[d.key]);
      if (!on) continue;
      dayMap[d.key].push({ role: t.role, startMin: s, endMin: e });
    }
  }

  for (const d of dayOrder) {
    const layout = layoutDay(dayMap[d.key]);
    result[d.key] = { day: d.key, lanes: layout.lanes, laneCount: layout.laneCount };
  }

  return result;
}

function minutesToLeft(min: number) {
  return ((min - START_HOUR * 60) / 60) * HOUR_WIDTH;
}

function minutesToWidth(startMin: number, endMin: number) {
  return ((endMin - startMin) / 60) * HOUR_WIDTH;
}

// Role coloring helpers
function hashHue(input: string): number {
  let h = 0;
  for (let i = 0; i < input.length; i++) {
    h = (h * 31 + input.charCodeAt(i)) >>> 0;
  }
  return h % 360;
}

function roleStyles(role: string): { bg: string; border: string; text: string } {
  const hue = hashHue(role || "role");
  const bg = `hsl(${hue}, 85%, 85%)`;
  const border = `hsl(${hue}, 60%, 50%)`;
  const text = `hsl(220, 43%, 11%)`; // slate-900
  return { bg, border, text };
}

function fmt(min: number) {
  const hh = Math.floor(min / 60).toString().padStart(2, "0");
  const mm = (min % 60).toString().padStart(2, "0");
  return `${hh}:${mm}`;
}

export default function SchedulePage() {
  const { templates, employees, loading, error } = useSetup();

  const layouts = useMemo(() => buildLayouts(templates), [templates]);
  const hours = useMemo(() => Array.from({ length: END_HOUR - START_HOUR + 1 }, (_, i) => START_HOUR + i), []);
  const totalWidth = (END_HOUR - START_HOUR) * HOUR_WIDTH;

  // Left panel state
  const [availDay, setAvailDay] = useState<DayKey>("MON");
  const availableEmployees = useMemo(() => {
    const idxMap: Record<DayKey, number> = { MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6, SUN: 0 };
    const i = idxMap[availDay];
    return employees.filter((e) => {
      const slot = e.availability?.[i];
      return slot && !slot.isOff;
    });
  }, [employees, availDay]);

  // Assignments (local draft only): key = `${day}|${start}|${end}` -> employee name
  const [assignments, setAssignments] = useState<Record<string, string>>({});

  // modal state for quick view/edit
  const [open, setOpen] = useState(false);
  const [selected, setSelected] = useState<null | { day: DayKey; role: string; startMin: number; endMin: number }>(null);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <button onClick={() => alert("AI generate (stub)")} className="rounded border px-3 py-2 text-sm">AI Generate</button>
          <button onClick={() => alert("Solver generate (stub)")} className="rounded border px-3 py-2 text-sm">Solver Generate</button>
        </div>
      </div>

      <div className="grid grid-cols-1 gap-4 lg:grid-cols-[280px_minmax(0,1fr)_320px]">
        {/* Left: Availabilities */}
        <aside className="rounded-lg border bg-white p-3">
          <div className="flex items-center justify-between">
            <h2 className="text-sm font-semibold text-slate-900">Worker availabilities</h2>
            <select className="rounded border px-2 py-1 text-sm" onChange={(e) => setAvailDay(e.target.value as DayKey)} value={availDay}>
              {dayOrder.map((d) => (
                <option key={d.key} value={d.key}>{d.label}</option>
              ))}
            </select>
          </div>
          <div className="mt-3 space-y-2">
            {availableEmployees.length === 0 ? (
              <div className="text-xs text-slate-500">No available workers for this day.</div>
            ) : (
              availableEmployees.map((emp, idx) => (
                <div
                  key={idx}
                  className="flex items-center justify-between rounded border px-2 py-1 text-xs"
                  draggable
                  onDragStart={(ev) => {
                    ev.dataTransfer.setData('text/plain', JSON.stringify({ employeeIndex: emp._index }));
                  }}
                  title={`${emp.name} • ${emp.label}`}
                >
                  <div className="min-w-0">
                    <div className="truncate font-medium text-slate-900">{emp.name}</div>
                    <div className="truncate text-[11px] text-slate-500">{emp.label}</div>
                  </div>
                  <span className="ml-2 inline-flex h-3 w-3 rounded-full" style={{ backgroundColor: emp.color }} />
                </div>
              ))
            )}
          </div>
        </aside>

        {/* Center: Timeline */}
        <section>
          {loading ? (
            <div className="rounded-lg border bg-white p-6 text-sm text-slate-500">Loading…</div>
          ) : error ? (
            <div className="rounded-lg border bg-white p-6 text-sm text-red-600">{error}</div>
          ) : (
            <div className="overflow-x-auto rounded-lg border bg-white">
              {/* Hour header */}
              <div className="sticky top-0 z-10 border-b bg-slate-50">
                <div className="relative ml-20" style={{ width: totalWidth }}>
                  <div className="grid" style={{ gridTemplateColumns: `repeat(${END_HOUR - START_HOUR}, ${HOUR_WIDTH}px)` }}>
                    {hours.slice(0, -1).map((h) => (
                      <div key={h} className="relative border-r border-slate-200 py-2 text-center text-xs text-slate-600">
                        {String(h).padStart(2, "0")}:00
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              {/* Days */}
              <div className="divide-y">
                {dayOrder.map((d) => {
                  const layout = layouts[d.key];
                  const computed = layout.laneCount * LANE_HEIGHT + Math.max(0, layout.laneCount - 1) * LANE_GAP + 16; // padding
                  const rowHeight = Math.max(MIN_ROW_HEIGHT, computed);

                  return (
                    <div key={d.key} className="relative" style={{ height: rowHeight }}>
                      {/* Day label */}
                      <div className="absolute left-0 top-0 flex h-full w-20 items-start justify-start px-3 py-2">
                        <span className="rounded bg-slate-100 px-2 py-1 text-xs font-medium text-slate-700">{d.label}</span>
                      </div>

                      {/* Grid + blocks */}
                      <div className="ml-20 h-full">
                        <div className="relative" style={{ width: totalWidth, height: "100%" }}>
                          {/* Vertical hour grid */}
                          <div className="absolute inset-0 grid" style={{ gridTemplateColumns: `repeat(${END_HOUR - START_HOUR}, ${HOUR_WIDTH}px)` }}>
                            {hours.slice(0, -1).map((h) => (
                              <div key={h} className="border-r border-slate-100" />
                            ))}
                          </div>

                          {/* Blocks or empty state */}
                          <div className="relative h-full">
                            {layout.lanes.length === 0 ? (
                              <div className="flex h-full items-center justify-center">
                                <span className="text-xs text-slate-400">No shifts</span>
                              </div>
                            ) : (
                              layout.lanes.map((b, idx) => {
                                const left = minutesToLeft(b.startMin);
                                const width = minutesToWidth(b.startMin, b.endMin);
                                const top = 8 + b.lane * (LANE_HEIGHT + LANE_GAP);
                                const { bg, border, text } = roleStyles(b.role);
                                const key = `${d.key}|${b.startMin}|${b.endMin}`;
                                const assigned = assignments[key];
                                return (
                                  <button
                                    key={idx}
                                    className="absolute overflow-hidden rounded-md border px-2 py-1 text-xs shadow-sm focus:outline-none focus:ring-2 focus:ring-slate-300"
                                    style={{ left, width, top, height: LANE_HEIGHT, backgroundColor: bg, borderColor: border, color: text }}
                                    title={`${b.role} — ${fmt(b.startMin)} ? ${fmt(b.endMin)}`}
                                    onClick={() => { setSelected({ day: d.key, role: b.role, startMin: b.startMin, endMin: b.endMin }); setOpen(true); }}
                                    onDragOver={(ev) => ev.preventDefault()}
                                    onDrop={(ev) => {
                                      try {
                                        const data = JSON.parse(ev.dataTransfer.getData('text/plain'));
                                        const emp: Employee | undefined = employees[data.employeeIndex as number];
                                        if (!emp) return;
                                        const idxMap: Record<DayKey, number> = { MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6, SUN: 0 };
                                        const dayIdx = idxMap[d.key];
                                        const slot = emp.availability?.[dayIdx];
                                        if (!slot || slot.isOff) { alert(`${emp.name} is off on ${d.label}`); return; }
                                        const s = timeToMinutes(slot.startTime);
                                        const e = timeToMinutes(slot.endTime);
                                        if (!(s <= b.startMin && e >= b.endMin)) { alert(`${emp.name} is not available for this time`); return; }
                                        setAssignments((prev) => ({ ...prev, [key]: emp.name }));
                                      } catch {}
                                    }}
                                  >
                                    <span className="font-medium">{b.role}</span>
                                    {assigned && (
                                      <span className="ml-2 truncate text-[11px] text-slate-700">• {assigned}</span>
                                    )}
                                  </button>
                                );
                              })
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
        </section>

        {/* Right: AI Chat */}
        <aside className="flex h-full flex-col rounded-lg border bg-white">
          <div className="border-b p-3 text-sm font-semibold text-slate-900">AI Assistant</div>
          <ChatPane />
        </aside>
      </div>

      {/* Quick view/edit modal */}
      <Modal open={open} onClose={() => setOpen(false)} title="Shift template">
        {selected ? (
          <div className="space-y-4 text-sm">
            <div className="grid grid-cols-3 gap-2">
              <div className="text-slate-500">Day</div>
              <div className="col-span-2 font-medium text-slate-900">{dayOrder.find((x) => x.key === selected.day)?.label}</div>
              <div className="text-slate-500">Role</div>
              <div className="col-span-2 font-medium text-slate-900">{selected.role}</div>
              <div className="text-slate-500">Time</div>
              <div className="col-span-2 font-medium text-slate-900">{fmt(selected.startMin)} – {fmt(selected.endMin)}</div>
            </div>
            <div className="flex items-center justify-between">
              <Link href="/schedule/shifts" className="text-slate-700 underline">Edit in Shifts</Link>
              <button type="button" onClick={() => setOpen(false)} className="rounded-md border px-3 py-2">Close</button>
            </div>
          </div>
        ) : null}
      </Modal>
    </div>
  );
}

function ChatPane() {
  const [chat, setChat] = useState<{ role: 'user' | 'assistant'; content: string }[]>([]);
  const [input, setInput] = useState('');
  return (
    <div className="flex h-full flex-col">
      <div className="flex-1 space-y-2 overflow-y-auto p-3 text-sm">
        {chat.length === 0 ? (
          <div className="text-xs text-slate-500">Ask me to modify the schedule.</div>
        ) : (
          chat.map((m, i) => (
            <div key={i} className={m.role === 'user' ? 'text-right' : ''}>
              <div className={`inline-block rounded px-2 py-1 ${m.role === 'user' ? 'bg-slate-900 text-white' : 'bg-slate-100 text-slate-900'}`}>{m.content}</div>
            </div>
          ))
        )}
      </div>
      <form
        className="flex gap-2 border-t p-2"
        onSubmit={async (e) => {
          e.preventDefault();
          if (!input.trim()) return;
          const msg = input.trim();
          setChat((c) => [...c, { role: 'user', content: msg }]);
          setInput('');
          try {
            const res = await fetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: msg }) });
            const data = await res.json();
            setChat((c) => [...c, { role: 'assistant', content: data.reply || '…' }]);
          } catch {
            setChat((c) => [...c, { role: 'assistant', content: 'Sorry, I could not reply.' }]);
          }
        }}
      >
        <input value={input} onChange={(e) => setInput(e.target.value)} placeholder="Ask to adjust shifts…" className="flex-1 rounded border px-2 py-1 text-sm" />
        <button className="rounded bg-slate-900 px-3 py-1 text-sm text-white">Send</button>
      </form>
    </div>
  );
}


